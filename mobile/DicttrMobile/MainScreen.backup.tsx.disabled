import React, { useState, useEffect } from 'react';
import { StatusBar } from 'expo-status-bar';
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  StatusBar as RNStatusBar,
  Platform,
} from 'react-native';
import { Audio } from 'expo-av';
import { useNavigation } from '@react-navigation/native';
import { transcriptionAPI, transcriptionManagementAPI } from './services/api';
import MermaidView from './components/MermaidView';
import JSONRenderer from './components/JSONRenderer';
import JSONRendererPreview from './components/JSONRendererPreview';
import ModalEditor from './components/ModalEditor';
import AudioRecorder from './components/AudioRecorder';
import TranscriptionView from './components/TranscriptionView';
import Header from './components/Header';
import ModalManager from './components/ModalManager';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from './contexts/AuthContext';
import { generateStudyMaterial } from './components/StudyMaterialGenerator';
import { processRecording } from './components/RecordingProcessor';
import { handleDeleteElement, handleUpdateElement, handleAddElement } from './components/ModalHandlers';
import { formatDuration, getCurrentTime, hideNavigationBar } from './components/utils';

interface Recording {
  sound: Audio.Sound;
  uri: string;
}

function MainScreen() {
  const { logout } = useAuth();
  const navigation = useNavigation<any>();
  
  // Esperar a que el navigation esté disponible y manejar parámetros
  useEffect(() => {
    if (navigation) {
      console.log('Navigation disponible');
    }

    // Escuchar cambios en los parámetros de navegación
    const unsubscribe = navigation.addListener('focus', async () => {
      const params = navigation.getState()?.routes?.[navigation.getState().index]?.params;
      
      // Manejar transcriptionData (formato antiguo)
      if (params?.transcriptionData) {
        // Cargar la transcripción desde los parámetros de navegación
        const { transcriptionData } = params;
        console.log('Cargando transcripción desde navegación:', transcriptionData);
        setTranscriptionText(transcriptionData.original_text || '');
        
        // Parsear enhanced_text si es un string JSON
        let enhancedData = transcriptionData.enhanced_text || null;
        if (typeof enhancedData === 'string') {
          try {
            enhancedData = JSON.parse(enhancedData);
            console.log('✅ Enhanced text parseado correctamente desde JSON string');
          } catch (error) {
            console.error('Error parseando enhanced_text JSON:', error);
            // Mantener como string si hay error al parsear
          }
        }
        setEnhancedText(enhancedData);

        // NO limpiar los parámetros para mantener la persistencia al navegar
        // navigation.setParams({ transcriptionData: undefined });
      }
      
      // Manejar transcriptionId (nuevo formato)
      else if (params?.transcriptionId) {
        const { transcriptionId } = params;
        console.log('Cargando transcripción desde ID:', transcriptionId);
        setCurrentTranscriptionId(transcriptionId);
        
        try {
          setLoading(true);
          // Obtener los datos de la transcripción desde la API
          const response = await transcriptionManagementAPI.getTranscription(transcriptionId);
          
          if (response.success && response.data) {
            const transcriptionData = response.data;
            console.log('Transcripción cargada desde API:', transcriptionData);
            
            setTranscriptionText(transcriptionData.original_text || '');
            
            // Parsear enhanced_text si es un string JSON
            let enhancedData = transcriptionData.enhanced_text || null;
            if (typeof enhancedData === 'string') {
              try {
                enhancedData = JSON.parse(enhancedData);
                console.log('✅ Enhanced text parseado correctamente desde JSON string');
              } catch (error) {
                console.error('Error parseando enhanced_text JSON:', error);
                // Mantener como string si hay error al parsear
              }
            }
            setEnhancedText(enhancedData);
          } else {
            Alert.alert('Error', 'No se pudo cargar la transcripción');
          }
        } catch (error) {
          console.error('Error loading transcription:', error);
          Alert.alert('Error', 'No se pudo cargar la transcripción');
        } finally {
          setLoading(false);
          // NO limpiar el parámetro para mantener la persistencia al navegar
          // navigation.setParams({ transcriptionId: undefined });
        }
      }
    });

    return unsubscribe;
  }, [navigation]);

  // Crear una función de navegación segura con retraso
  const navigateToTranscriptions = () => {
    console.log('Intentando navegar a Transcriptions');
    // Usar setTimeout para dar tiempo a que el navigation esté completamente inicializado
    setTimeout(() => {
      if (navigation && navigation.navigate) {
        try {
          navigation.navigate('Transcriptions');
          console.log('Navegación exitosa');
        } catch (error) {
          console.error('Error al navegar:', error);
          Alert.alert('Error', 'No se puede acceder a las transcripciones en este momento');
        }
      } else {
        console.error('Navigation no disponible');
        Alert.alert('Error', 'La navegación no está disponible');
      }
    }, 1000); // Aumentar el tiempo de espera a 1000ms (1 segundo)
  };
  const [recording, setRecording] = useState<Audio.Recording | null>(null);
  const [isRecording, setIsRecording] = useState(false);
  const [recordings, setRecordings] = useState<Recording[]>([]);
  const [transcriptionText, setTranscriptionText] = useState('');
  const [enhancedText, setEnhancedText] = useState<any>(null);
  const [studyMaterial, setStudyMaterial] = useState('');
  const [mermaidCode, setMermaidCode] = useState('');
  const [loading, setLoading] = useState(false);
  const [recordingDuration, setRecordingDuration] = useState(0);
  const [showOriginalTranscription, setShowOriginalTranscription] = useState(false);
  const [showEnhancedTranscription, setShowEnhancedTranscription] = useState(true);
  const [showTranscriptionModal, setShowTranscriptionModal] = useState(false);
  const [showOriginalTranscriptionModal, setShowOriginalTranscriptionModal] = useState(false);
  const [showEnhancedPreviewModal, setShowEnhancedPreviewModal] = useState(false);
  const [showMaterialMenu, setShowMaterialMenu] = useState(false);
  const [showModalEditor, setShowModalEditor] = useState(false);
  const [editingContent, setEditingContent] = useState<any>(null);
  const [editingElement, setEditingElement] = useState<any>(null);
  const [editingPath, setEditingPath] = useState<string>('');
  const [currentTranscriptionId, setCurrentTranscriptionId] = useState<string | null>(null);

  useEffect(() => {
    requestPermissions();
    hideNavigationBar();
  }, []);



  const hideNavigationBar = () => {
    // Función utilitaria importada desde utils.ts
    if (Platform.OS === 'android') {
      try {
        // Ocultar barra de navegación en Android
        RNStatusBar.setHidden(true, 'slide');

        // Forzar modo immersive (puede no funcionar en todos los dispositivos)
        // Esta es una aproximación ya que Expo limita el acceso a APIs nativas
        setTimeout(() => {
          RNStatusBar.setHidden(false, 'slide');
          setTimeout(() => RNStatusBar.setHidden(true, 'slide'), 100);
        }, 500);
      } catch (error) {
        console.log('No se pudo ocultar la barra de navegación:', error);
      }
    }
  };

  const requestPermissions = async () => {
    try {
      const { status } = await Audio.requestPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permisos requeridos', 'Necesitamos permisos de audio para grabar las clases');
      }
    } catch (error) {
      console.error('Error requesting permissions:', error);
    }
  };

  const startRecording = async () => {
    try {
      const { status } = await Audio.getPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Error', 'No hay permisos de audio');
        return;
      }

      await Audio.setAudioModeAsync({
        allowsRecordingIOS: true,
        playsInSilentModeIOS: true,
      });

      // Configuración específica para M4A mono a 16kHz (formato compatible con Whisper)
      const recordingOptions = {
        android: {
          extension: '.m4a',
          outputFormat: Audio.AndroidOutputFormat.MPEG_4,
          audioEncoder: Audio.AndroidAudioEncoder.AAC,
          sampleRate: 16000,
          numberOfChannels: 1,
          bitRate: 32000,
        },
        ios: {
          extension: '.m4a',
          outputFormat: Audio.IOSOutputFormat.MPEG4AAC,
          audioQuality: Audio.IOSAudioQuality.MIN,
          sampleRate: 16000,
          numberOfChannels: 1,
          bitRate: 32000,
          linearPCMBitDepth: 16,
          linearPCMIsBigEndian: false,
          linearPCMIsFloat: false,
        },
        web: {
          mimeType: 'audio/mp4',
          bitsPerSecond: 32000,
        },
      };

      const { recording } = await Audio.Recording.createAsync(
        recordingOptions
      );

      setRecording(recording);
      setIsRecording(true);
      setRecordingDuration(0);

      // Timer para mostrar duración
      const interval = setInterval(() => {
        setRecordingDuration(prev => prev + 1);
      }, 1000);

      recording.setOnRecordingStatusUpdate((status) => {
        if (!status.isRecording && interval) {
          clearInterval(interval);
        }
      });

    } catch (error) {
      console.error('Error starting recording:', error);
      Alert.alert('Error', 'No se pudo iniciar la grabación');
    }
  };

  const stopRecording = async () => {
    if (!recording) return;

    try {
      setIsRecording(false);
      await recording.stopAndUnloadAsync();
      
      const uri = recording.getURI();
      if (uri) {
        const { sound } = await Audio.Sound.createAsync({ uri });
        setRecordings(prev => [...prev, { sound, uri }]);
        
        // Procesar automáticamente la grabación
        await processRecording(uri, { setLoading, setTranscriptionText, setEnhancedText });
      }
      
      setRecording(null);
      setRecordingDuration(0);
    } catch (error) {
      console.error('Error stopping recording:', error);
      Alert.alert('Error', 'No se pudo detener la grabación');
    }
  };

  const handleProcessRecording = async (audioUri: string) => {
    await processRecording(audioUri, { setLoading, setTranscriptionText, setEnhancedText });
  };

  const generateStudyMaterial = async (type: 'summary' | 'flashcards' | 'concepts' | 'quiz' | 'flowchart') => {
    await generateStudyMaterial(
      { enhancedText, setStudyMaterial, setMermaidCode, setLoading },
      type
    );
  };

  // Navegar al editor de bloques con IA
  const openBlockEditor = () => {
    if (!enhancedText || Object.keys(enhancedText).length === 0) {
      Alert.alert('Error', 'Primero debes tener una transcripción mejorada');
      return;
    }
  };


  const formatDuration = (seconds: number) => {
    return formatDuration(seconds);
  };

  const openFullScreenTranscription = () => {
    setShowTranscriptionModal(true);
  };

  const closeFullScreenTranscription = () => {
    setShowTranscriptionModal(false);
  };

  const getCurrentTime = () => {
    return getCurrentTime();
  };

  const handleDeleteElement = (path: string, element: any) => {
    handleDeleteElement(path, { enhancedText, setEnhancedText });
  };

  const handleUpdateElement = async (path: string, element: any) => {
    await handleUpdateElement(path, element, { enhancedText, setEnhancedText, currentTranscriptionId });
  };

  const handleAddElement = (typeOrBlock: string | any, position?: number) => {
    const updatedData = handleAddElement(typeOrBlock, position, { enhancedText, setEnhancedText });

    // Abrir automáticamente el modal de edición para el nuevo bloque
    if (updatedData && updatedData.sections) {
      const newSectionIndex = position !== undefined ? position : updatedData.sections.length - 1;
      const newSectionPath = `sections.${newSectionIndex}`;
      const newSection = updatedData.sections[newSectionIndex];

      // Usar setTimeout para asegurar que el estado se actualice antes de abrir el modal
      setTimeout(() => {
        openModalEditor(newSection, newSectionPath, newSection);
      }, 100);
    }
  };

  const openModalEditor = (content: any, path: string = '', element: any = null) => {
    console.log('openModalEditor llamado con content:', typeof content, JSON.stringify(content));
    console.log('openModalEditor llamado con path:', path);
    console.log('openModalEditor llamado con element:', typeof element, JSON.stringify(element));
    setEditingContent(content);
    setEditingElement(element);
    setEditingPath(path);
    setShowModalEditor(true);
  };

  const closeModalEditor = () => {
    setShowModalEditor(false);
    setEditingContent(null);
    setEditingElement(null);
    setEditingPath('');
  };

  const handleExportToPDF = async () => {
    if (!enhancedText) {
      Alert.alert('Error', 'No hay contenido para exportar');
      return;
    }

    console.log('📄 EnhancedText content for PDF export:', JSON.stringify(enhancedText, null, 2));

    try {
      setLoading(true);
      
      // Convertir el contenido a texto plano para el PDF
      let pdfContent = '';
      
      // Procesar los datos para extraer el contenido textual
      let parsedData = enhancedText;
      
      // Si los datos vienen como string JSON dentro de raw_content, parsearlos primero
      if (typeof enhancedText === 'object' && enhancedText.raw_content) {
        try {
          // Extraer el JSON del string que puede contener markdown
          const jsonMatch = enhancedText.raw_content.match(/```json\n([\s\S]*?)\n```/) || enhancedText.raw_content.match(/{[\s\S]*}/);
          if (jsonMatch) {
            parsedData = JSON.parse(jsonMatch[1] || jsonMatch[0]);
            console.log('✅ JSON parsed successfully from raw_content');
          } else {
            // Si no hay markdown, intentar parsear directamente
            parsedData = JSON.parse(enhancedText.raw_content);
          }
        } catch (error) {
          console.error('Error parsing JSON from raw_content:', error);
          // Mantener los datos originales si hay error al parsear
          parsedData = enhancedText;
        }
      }
      
      if (typeof parsedData === 'object') {
        // Título principal
        if (parsedData.title) {
          pdfContent += `TÍTULO: ${parsedData.title}\n\n`;
        }
        
        // Resumen
        if (parsedData.summary) {
          pdfContent += `RESUMEN: ${parsedData.summary}\n\n`;
        }
        
        // Secciones
        if (parsedData.sections) {
          parsedData.sections.forEach((section: any, index: number) => {
            pdfContent += `\n--- SECCIÓN ${index + 1} ---\n`;
            
            switch (section.type) {
              case 'heading':
                pdfContent += `TÍTULO (Nivel ${section.level || 2}): ${section.content || ''}\n\n`;
                break;
              case 'paragraph':
                pdfContent += `${section.content || ''}\n\n`;
                break;
              case 'list':
                if (section.items) {
                  section.items.forEach((item: string, itemIndex: number) => {
                    pdfContent += `• ${item}\n`;
                  });
                  pdfContent += '\n';
                }
                break;
              case 'concept_block':
                pdfContent += `CONCEPTO: ${section.term || ''}\n`;
                if (section.definition) {
                  pdfContent += `DEFINICIÓN: ${section.definition}\n`;
                }
                if (section.examples && section.examples.length > 0) {
                  pdfContent += 'EJEMPLOS:\n';
                  section.examples.forEach((example: string) => {
                    pdfContent += `- ${example}\n`;
                  });
                }
                pdfContent += '\n';
                break;
              case 'summary_block':
                pdfContent += `📋 RESUMEN:\n${section.content || ''}\n\n`;
                break;
              case 'key_concepts_block':
                if (section.concepts && section.concepts.length > 0) {
                  pdfContent += '🔑 CONCEPTOS CLAVE:\n';
                  section.concepts.forEach((concept: string) => {
                    pdfContent += `• ${concept}\n`;
                  });
                  pdfContent += '\n';
                }
                break;
              default:
                pdfContent += `${section.content || JSON.stringify(section, null, 2)}\n\n`;
            }
          });
        }
        
        // Conceptos clave
        if (parsedData.key_concepts) {
          pdfContent += '🔑 CONCEPTOS CLAVE:\n';
          parsedData.key_concepts.forEach((concept: string) => {
            pdfContent += `• ${concept}\n`;
          });
          pdfContent += '\n';
        }
      } else {
        // Si es texto plano
        pdfContent = parsedData;
      }
      
      console.log('📄 PDF content to send:', pdfContent);
      
      // Enviar al backend para generar PDF
      const response = await transcriptionAPI.exportToPDF(pdfContent);
      
      if (response.success && response.data?.download_url) {
        Alert.alert('✅ Éxito', 'PDF generado correctamente');
        
        // Usar la URL de descarga directa para descargar el PDF
        const downloadUrl = response.data.download_url;
        console.log('📥 Download URL:', downloadUrl);
        
        // Intentar descargar el PDF directamente
        try {
          // Usar Linking para abrir la URL de descarga
          const { Linking } = require('react-native');
          const canOpen = await Linking.canOpenURL(downloadUrl);
          
          if (canOpen) {
            await Linking.openURL(downloadUrl);
            Alert.alert('✅ Descarga Iniciada', 'La descarga del PDF ha comenzado. El archivo se guardará en tu dispositivo.');
          } else {
            // Si no se puede abrir directamente, mostrar la URL para copiar
            Alert.alert('⚠️ Atención', 
              'PDF generado correctamente. Puedes descargarlo desde:\n\n' + 
              downloadUrl + 
              '\n\nCopia esta URL y ábrela en tu navegador.'
            );
          }
        } catch (downloadError) {
          console.error('Error downloading PDF:', downloadError);
          Alert.alert('⚠️ PDF Generado', 
            'PDF creado exitosamente. URL de descarga: ' + downloadUrl + 
            '\n\nPuedes copiar esta URL y abrirla en tu navegador para descargar el archivo.'
          );
        }
      } else if (response.success && response.data?.pdf_url) {
        // Fallback a la URL de visualización si no hay URL de descarga
        Alert.alert('✅ Éxito', 'PDF generado correctamente');
        const pdfUrl = response.data.pdf_url;
        console.log('📄 PDF URL (fallback):', pdfUrl);
        
        try {
          const { Linking } = require('react-native');
          const canOpen = await Linking.canOpenURL(pdfUrl);
          
          if (canOpen) {
            await Linking.openURL(pdfUrl);
            Alert.alert('✅ PDF Listo', 'El PDF se ha abierto en tu navegador. Puedes descargarlo desde allí.');
          } else {
            Alert.alert('⚠️ Atención', 
              'PDF generado correctamente. Puedes acceder a él en:\n\n' + 
              pdfUrl + 
              '\n\nDesde un navegador web.'
            );
          }
        } catch (openError) {
          console.error('Error opening PDF:', openError);
          Alert.alert('⚠️ PDF Generado', 
            'PDF creado exitosamente. URL: ' + pdfUrl + 
            '\n\nPuedes copiar esta URL y abrirla en tu navegador para descargar el archivo.'
          );
        }
      } else {
        Alert.alert('Error', 'No se pudo generar el PDF o no se recibió la URL de descarga');
      }
      
    } catch (error) {
      console.error('Error exporting to PDF:', error);
      Alert.alert('Error', 'No se pudo generar el PDF. Verifica tu conexión.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar style="dark" />
      
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
        {/* Header elegante */}
        <Header
          enhancedText={enhancedText}
          navigateToTranscriptions={navigateToTranscriptions}
          logout={logout}
        />

        {/* Contenido principal */}
        <View style={styles.content}>


          {/* Transcripción Mejorada - Ventana Minimizable */}
          <TranscriptionView
            enhancedText={enhancedText}
            transcriptionText={transcriptionText}
            showEnhancedTranscription={showEnhancedTranscription}
            setShowEnhancedTranscription={setShowEnhancedTranscription}
            setShowOriginalTranscriptionModal={setShowOriginalTranscriptionModal}
            setShowEnhancedPreviewModal={setShowEnhancedPreviewModal}
            loading={loading}
            onEdit={(path, element) => {
              console.log('Editando elemento:', path, element);
              console.log('Elemento a editar estructura:', JSON.stringify(element, null, 2));

              // Determinar el contenido a editar basado en el tipo de elemento
              let contentToEdit = element;

              // Para el título principal (objeto con title/summary)
              if (element.title !== undefined && path === 'title') {
                contentToEdit = element.title;
              }
              // Para elementos que son strings simples
              else if (typeof element === 'string') {
                contentToEdit = element;
              }
              // Para todas las secciones, mantener el objeto completo para que el editor
              // pueda acceder a todas las propiedades (type, content, term, definition, etc.)

              console.log('Abriendo modal editor con contenido:', contentToEdit);
              console.log('Tipo de contenido:', typeof contentToEdit);
              openModalEditor(contentToEdit, path, element);
            }}
            onDelete={handleDeleteElement}
            onAdd={handleAddElement}
            openModalEditor={openModalEditor}
          />

          {/* Botones de Material de Estudio - ELIMINADOS DE LA PANTALLA PRINCIPAL */}
          {/* Estos botones se moverán a un menú desplegable en la parte inferior */}

          {/* Material de Estudio Generado */}
          {studyMaterial ? (
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>
                {studyMaterial.includes('FLUJOGRAMA') ? '📊 Flujograma Generado' : 'Material de Estudio:'}
              </Text>
              <View style={
                studyMaterial.includes('FLUJOGRAMA') 
                  ? styles.flowchartContainer 
                  : styles.materialContainer
              }>
                <Text style={
                  studyMaterial.includes('FLUJOGRAMA')
                    ? styles.flowchartText
                    : styles.materialText
                }>
                  {studyMaterial}
                </Text>
              </View>
            </View>
          ) : null}

          {/* Visualización del Diagrama Mermaid */}
          {mermaidCode ? (
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>📊 Visualización del Diagrama:</Text>
              <MermaidView 
                mermaidCode={mermaidCode} 
                height={400}
                style={styles.mermaidView}
              />
              <Text style={styles.mermaidHelp}>
                💡 Diagrama generado automáticamente a partir de tu contenido
              </Text>
            </View>
          ) : null}



          {/* Loading Indicator */}
          {loading && (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color="#4A00E0" />
              <Text style={styles.loadingText}>Procesando con IA...</Text>
            </View>
          )}
        </View>
      </ScrollView>

      {/* Barra de grabación fija en la parte inferior */}
      <AudioRecorder
        onRecordingProcessed={handleProcessRecording}
        loading={loading}
      />

      {/* Menú desplegable de material de estudio */}
      {showMaterialMenu && (
        <View style={styles.materialMenu}>
          <TouchableOpacity
            style={styles.materialMenuItem}
            onPress={() => {
              generateStudyMaterial('summary');
              setShowMaterialMenu(false);
            }}
            disabled={loading}
          >
            <Ionicons name="document-text" size={20} color="#4A00E0" />
            <Text style={styles.materialMenuItemText}>Resumen</Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.materialMenuItem}
            onPress={() => {
              generateStudyMaterial('flashcards');
              setShowMaterialMenu(false);
            }}
            disabled={loading}
          >
            <Ionicons name="albums" size={20} color="#4A00E0" />
            <Text style={styles.materialMenuItemText}>Flashcards</Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.materialMenuItem}
            onPress={() => {
              generateStudyMaterial('concepts');
              setShowMaterialMenu(false);
            }}
            disabled={loading}
          >
            <Ionicons name="bulb" size={20} color="#4A00E0" />
            <Text style={styles.materialMenuItemText}>Conceptos</Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.materialMenuItem}
            onPress={() => {
              generateStudyMaterial('quiz');
              setShowMaterialMenu(false);
            }}
            disabled={loading}
          >
            <Ionicons name="help-circle" size={20} color="#4A00E0" />
            <Text style={styles.materialMenuItemText}>Quiz</Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.materialMenuItem}
            onPress={() => {
              generateStudyMaterial('flowchart');
              setShowMaterialMenu(false);
            }}
            disabled={loading}
          >
            <Ionicons name="git-branch" size={20} color="#4A00E0" />
            <Text style={styles.materialMenuItemText}>Flujograma</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.materialMenuItem}
            onPress={() => {
              openBlockEditor();
              setShowMaterialMenu(false);
            }}
            disabled={loading}
          >
            <Ionicons name="document" size={20} color="#4A00E0" />
            <Text style={styles.materialMenuItemText}>Editor IA</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={styles.materialMenuItem}
            onPress={() => {
              // Navegar a la pantalla de transcripciones
              navigation.navigate('Transcriptions');
              setShowMaterialMenu(false);
            }}
            disabled={loading}
          >
            <Ionicons name="list" size={20} color="#4A00E0" />
            <Text style={styles.materialMenuItemText}>Mis Transcripciones</Text>
          </TouchableOpacity>
        </View>
      )}


      {/* Modal para Transcripción Completa */}
      <ModalManager
        showTranscriptionModal={showTranscriptionModal}
        closeFullScreenTranscription={closeFullScreenTranscription}
        transcriptionText={transcriptionText}
        showOriginalTranscriptionModal={showOriginalTranscriptionModal}
        setShowOriginalTranscriptionModal={setShowOriginalTranscriptionModal}
        showEnhancedPreviewModal={showEnhancedPreviewModal}
        setShowEnhancedPreviewModal={setShowEnhancedPreviewModal}
        enhancedText={enhancedText}
        handleExportToPDF={handleExportToPDF}
      />

      {/* Modal Editor para editar bloques */}
      <ModalEditor
        visible={showModalEditor}
        onClose={closeModalEditor}
        initialContent={editingContent}
        onSave={(data) => {
          console.log('Guardando datos del modal:', data);
          // Aquí necesito implementar la lógica para guardar los cambios
          // en el bloque específico que se está editando
          if (editingElement) {
            // Para nuevos bloques, el path se maneja automáticamente en handleUpdateElement
            // Para bloques existentes, usar el path que se pasó al abrir el modal
            handleUpdateElement(editingPath, data);
          }
          closeModalEditor();
        }}
        selectedElement={editingElement}
        selectedPath={editingPath}
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f7fa',
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 80, // Espacio para la barra de grabación
  },
  header: {
    padding: 25,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    backgroundColor: 'white',
  },
  recordingTitle: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    marginBottom: 10,
  },
  transcriptionsButton: {
    padding: 6,
    borderRadius: 6,
    backgroundColor: '#f0f2f5',
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  tagSelectorButton: {
    padding: 6,
    borderRadius: 6,
    backgroundColor: '#f0f2f5',
  },
  folderSelectorButton: {
    padding: 6,
    borderRadius: 6,
    backgroundColor: '#f0f2f5',
  },
  logoutButton: {
    padding: 6,
    borderRadius: 6,
    backgroundColor: '#f0f2f5',
  },
  recordingName: {
    fontSize: 22,
    fontWeight: '600',
    color: '#333',
    flex: 1,
  },
  recordingTimeBadge: {
    backgroundColor: '#f0f2f5',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 12,
  },
  recordingTimeText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  meetingInfo: {
    fontSize: 14,
    color: '#666',
  },
  content: {
    padding: 12,
  },
  section: {
    marginBottom: 20,
    backgroundColor: 'white',
    borderRadius: 16,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 15,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '500',
  },
  recordingStatus: {
    color: '#4A00E0',
  },
  readyStatus: {
    color: '#666',
  },
  // Estilos para ventanas minimizables
  compactSection: {
    marginBottom: 15,
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  windowHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  windowActions: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  noteIconButton: {
    padding: 6,
    borderRadius: 6,
    backgroundColor: '#f0f2f5',
    marginRight: 8,
  },
  windowTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  editButton: {
    padding: 6,
    borderRadius: 6,
    backgroundColor: '#f0f2f5',
  },
  toggleButton: {
    padding: 4,
  },
  scrollContainerEnhanced: {
    flex: 1,
    minHeight: 400,
    marginTop: 10,
  },
  scrollViewCompact: {
    flex: 1,
  },
  scrollContentCompact: {
    padding: 8,
  },
  flowchartContainer: {
    backgroundColor: '#e6f7ff',
    padding: 16,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#1890ff',
    borderStyle: 'dashed',
  },
  materialContainer: {
    backgroundColor: '#fff8e1',
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#ffc107',
  },
  flowchartText: {
    fontSize: 14,
    fontFamily: 'monospace',
    lineHeight: 20,
    color: '#0050b3',
  },
  materialText: {
    fontSize: 15,
    lineHeight: 22,
    color: '#333',
  },
  mermaidView: {
    marginTop: 10,
  },
  mermaidHelp: {
    marginTop: 10,
    fontSize: 12,
    color: '#8c8c8c',
    fontStyle: 'italic',
    textAlign: 'center',
  },
  loadingContainer: {
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
  recordingSection: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    padding: 20,
    backgroundColor: '#f8f9fa',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  centerContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  timer: {
    fontSize: 18,
    fontWeight: '500',
    color: '#333',
    fontVariant: ['tabular-nums'],
  },
  buttonsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  materialMenuBtn: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#4A00E0',
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 3,
    elevation: 4,
  },
  materialMenuBtnActive: {
    backgroundColor: '#8E2DE2',
  },
  recordBtn: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#ff5e62',
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
  recordingBtn: {
    backgroundColor: '#4A00E0',
  },
  materialMenu: {
    position: 'absolute',
    bottom: 90,
    right: 20,
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 10,
    zIndex: 1000,
  },
  materialMenuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
    marginBottom: 5,
    backgroundColor: '#f8f9fa',
  },
  materialMenuItemText: {
    marginLeft: 10,
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  transcriptionModalContainer: {
    width: '90%',
    height: '80%',
    backgroundColor: 'white',
    borderRadius: 16,
    overflow: 'hidden',
    elevation: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f2f5',
    backgroundColor: '#fafafa',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
  },
  closeButton: {
    padding: 4,
  },
  modalContent: {
    flex: 1,
  },
  transcriptionScrollView: {
    flex: 1,
  },
  transcriptionContent: {
    padding: 16,
  },
  transcriptionModalText: {
    fontSize: 16,
    lineHeight: 24,
    color: '#333',
  },
  previewModalContainer: {
    width: '100%',
    height: '100%',
    backgroundColor: 'white',
  },
  previewModalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f2f5',
    backgroundColor: '#fafafa',
  },
  previewModalTitleRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    flex: 1,
  },
  previewModalTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
  },
  exportButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#e8f4fd',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#4A00E0',
  },
  exportButtonText: {
    marginLeft: 6,
    fontSize: 14,
    fontWeight: '600',
    color: '#4A00E0',
  },
  previewCloseButton: {
    position: 'absolute',
    top: 10,
    right: 10,
    zIndex: 1000,
    padding: 8,
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  previewModalContent: {
    flex: 1,
    padding: 0,
    margin: 0,
  },
  previewScrollView: {
    flex: 1,
  },
  previewContent: {
    padding: 0,
    margin: 0,
  },
});

export default MainScreen;
